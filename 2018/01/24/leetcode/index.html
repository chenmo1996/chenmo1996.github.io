<!DOCTYPE html>
<html>
  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Dekura&#39;s Blog">
  <meta name="keyword" content="hexo-theme, vuejs">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      LeetCode刷题记录 | Dekura
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png" />
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Dekura</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>LeetCode刷题记录</h2>
  <p class="post-date">2018-01-24</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p>正式踏上刷题LeetCode之旅，会一直更新的。<br><img src="http://osmisz4zw.bkt.clouddn.com/15167817989398.jpg" alt=""></p>
<a id="more"></a>
<h3 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h3><p>Two sum问题</p>
<h4 id="暴力解"><a href="#暴力解" class="headerlink" title="暴力解"></a>暴力解</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sol;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>;n &lt; nums.size();n++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n+<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[n]+nums[i]==target)&#123;</span><br><span class="line">                    sol.push_back(n);</span><br><span class="line">                    sol.push_back(i);</span><br><span class="line">                    <span class="keyword">return</span> sol;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="使用hash-对应CPP是-unordered-map"><a href="#使用hash-对应CPP是-unordered-map" class="headerlink" title="使用hash 对应CPP是 unordered_map"></a>使用hash 对应CPP是 unordered_map</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;nums.size(); i++)&#123;</span><br><span class="line">            res = target - nums[i];</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator it = mymap.find(res);</span><br><span class="line">            <span class="keyword">if</span>(it != mymap.end())&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Find the "</span>&lt;&lt;it-&gt;second &lt;&lt;<span class="string">" in map"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;it-&gt;second,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            mymap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>有关hashmap的补充：<br>首先我的理解是：hash是一个函数，能够通过映射关系实现O(1)的查找效率。<br>所以如果需要降低查找时间，是不是使用hash表都会更加方便呢？</li>
<li><a href="http://en.cppreference.com/w/cpp/container/unordered_map" target="_blank" rel="noopener">unordered_map API</a></li>
</ul>
<h3 id="3Sum问题"><a href="#3Sum问题" class="headerlink" title="3Sum问题"></a>3Sum问题</h3><p>这个问题有这么几个关键点：</p>
<ul>
<li>数组最大长度是<code>nums.size()-1</code>别越界了！</li>
<li>尽量少使用<code>++mid</code>这种做法，很容易搞糊涂</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将问题转换成 2sum问题</span></span><br><span class="line"><span class="comment"> * 从头开始遍历x：剩下两个数y,z为y+z=-x </span></span><br><span class="line"><span class="comment"> * 遍历x的时候有这么几个问题，如何保证不重复，因为数字是有可能重复的</span></span><br><span class="line"><span class="comment"> * 如何保证最后的结果是按照升序来完成的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解决方案</span></span><br><span class="line"><span class="comment"> * 首先进行排序，这就是为什么排序算法如此重要的原因吗</span></span><br><span class="line"><span class="comment"> * 使用三个指针：left,mid,right</span></span><br><span class="line"><span class="comment"> * 只用考虑left&lt;=0的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left,mid,right;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="comment">// if(nums.size()==3)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[0]+nums[1]+nums[2]==0)&#123;</span></span><br><span class="line">        <span class="comment">//         vector&lt;int&gt; ones = &#123;nums[0],nums[1],nums[2]&#125;;</span></span><br><span class="line">        <span class="comment">//         result.push_back(ones);</span></span><br><span class="line">        <span class="comment">//         return result;</span></span><br><span class="line">        <span class="comment">//     &#125;else&#123;</span></span><br><span class="line">        <span class="comment">//         return result;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span>(left=<span class="number">0</span>;left&lt;nums.size()&amp;&amp;nums[left]&lt;<span class="number">0</span>;left++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[left]==nums[left+<span class="number">1</span>]&amp;&amp;left&lt;nums.size()<span class="number">-1</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;left&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            </span><br><span class="line">            mid = left+<span class="number">1</span>;</span><br><span class="line">            right = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(mid&lt;right)&#123;</span><br><span class="line">                <span class="comment">// if(nums[mid]==nums[mid-1]&amp;&amp;mid&gt;1)&#123;</span></span><br><span class="line">                <span class="comment">//     mid++;</span></span><br><span class="line">                <span class="comment">//     std::cout&lt;&lt;mid&lt;&lt;endl;</span></span><br><span class="line">                <span class="comment">//     continue;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">                <span class="comment">// if(nums[right]==nums[right+1]&amp;&amp;right&lt;nums.size())&#123;</span></span><br><span class="line">                <span class="comment">//     right--;</span></span><br><span class="line">                <span class="comment">//     continue;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">               <span class="keyword">if</span>(nums[mid]+nums[right]+nums[left]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                    mid = mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]+nums[right]+nums[left]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    right=right<span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; oneans = &#123;nums[left],nums[mid],nums[right]&#125;;</span><br><span class="line">                    result.push_back(oneans);</span><br><span class="line">                    <span class="keyword">int</span> tmp_mid = nums[mid];</span><br><span class="line">                    <span class="keyword">int</span> tmp_right = nums[right];</span><br><span class="line">                    <span class="keyword">while</span>(mid&lt;right&amp;&amp;tmp_mid==nums[mid])&#123;</span><br><span class="line">                        mid++;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="keyword">while</span>(mid&lt;right&amp;&amp;tmp_right==nums[right])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="comment">// mid++;</span></span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="九章解法"><a href="#九章解法" class="headerlink" title="九章解法"></a>九章解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 本参考程序来自九章算法，由 @九章算法 提供。版权所有，转发请注明出处。</span></span><br><span class="line"><span class="comment">* - 九章算法致力于帮助更多中国人找到好的工作，教师团队均来自硅谷和国内的一线大公司在职工程师。</span></span><br><span class="line"><span class="comment">* - 现有的面试培训课程包括：九章算法班，系统设计班，算法强化班，Java入门与基础算法班，Android 项目实战班，</span></span><br><span class="line"><span class="comment">* - Big Data 项目实战班，算法面试高频题班, 动态规划专题班</span></span><br><span class="line"><span class="comment">* - 更多详情请见官方网站：http://www.jiuzhang.com/?source=code</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @param numbers : Give an array numbers of n integer</span></span><br><span class="line"><span class="comment">     * @return : Find all unique triplets in the array which gives the sum of zero.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; result;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// two sum;</span></span><br><span class="line">            <span class="keyword">int</span> start = i + <span class="number">1</span>, end = nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i];</span><br><span class="line">            <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">                <span class="keyword">if</span> (start &gt; i + <span class="number">1</span> &amp;&amp; nums[start - <span class="number">1</span>] == nums[start]) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nums[start] + nums[end] &lt; target) &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[start] + nums[end] &gt; target) &#123;</span><br><span class="line">                    end--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; triple;</span><br><span class="line">                    triple.push_back(nums[i]);</span><br><span class="line">                    triple.push_back(nums[start]);</span><br><span class="line">                    triple.push_back(nums[end]);</span><br><span class="line">                    result.push_back(triple);</span><br><span class="line">                    start++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111. Minimum Depth of Binary Tree"></a>111. Minimum Depth of Binary Tree</h3><h4 id="BFS解法"><a href="#BFS解法" class="headerlink" title="BFS解法"></a>BFS解法</h4><ul>
<li>这个和访问不一样，这是完整的访问完一层才加一个depth++；</li>
<li>一定一定要注意边界条件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * USE BFS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; nodeQueue;</span><br><span class="line">        nodeQueue.push(root);</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//考虑边界条件！ root == NULL</span></span><br><span class="line">        <span class="comment">//在PUSH的时候还要考虑 root-&gt;left是不是空的！！！</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            depth++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> k = nodeQueue.size();</span><br><span class="line">        <span class="comment">//这是要将一整层访问完毕才能够让深度加一</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode *left = nodeQueue.front()-&gt;left;</span><br><span class="line">                TreeNode *right = nodeQueue.front()-&gt;right;</span><br><span class="line">                <span class="keyword">if</span> (left)</span><br><span class="line">                    nodeQueue.push(left);</span><br><span class="line">                <span class="keyword">if</span> (right)</span><br><span class="line">                    nodeQueue.push(right);</span><br><span class="line">                nodeQueue.pop();</span><br><span class="line">                <span class="keyword">if</span> (left == <span class="literal">NULL</span> &amp;&amp; right == <span class="literal">NULL</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><ul>
<li>这个很关键的逻辑是：</li>
</ul>
<ol>
<li>如果左子树为空，则返回右子树的最小深度加1，而不是左子树不为空，返回左子树的最小深度！！！</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>) <span class="keyword">return</span> minDepth(root-&gt;right)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span> minDepth(root-&gt;left)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">NULL</span>&amp;&amp;root-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> min(minDepth(root-&gt;left),minDepth(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="链表：237-Delete-Node-in-a-Linked-List-easy"><a href="#链表：237-Delete-Node-in-a-Linked-List-easy" class="headerlink" title="链表：237. Delete Node in a Linked List -easy"></a>链表：237. Delete Node in a Linked List -easy</h3><p>哇，这个解法有个很不科学的地方,被删除的野指针怎么办？会被回收吗？<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val=node-&gt;next-&gt;val;</span><br><span class="line">        node-&gt;next=node-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="数组：Maximum-Length-of-Repeated-Subarray-Mid"><a href="#数组：Maximum-Length-of-Repeated-Subarray-Mid" class="headerlink" title="数组：Maximum Length of Repeated Subarray -Mid"></a>数组：Maximum Length of Repeated Subarray -Mid</h3><p>做这个题得出的结论就是！</p>
<ul>
<li>千万不要觉得以前做过类似的题目就想当然，一定要分析清楚和以前题目不同的地方在哪里</li>
<li>cpp二维数组balabala的index很容易搞混淆，如何才能快速准确的定位这些呢？</li>
<li>求最大值等题目解决思路可以是，设一个最大的旗标，当计算过程中出现更大的旗标的时候，就将最大值更换。</li>
</ul>
<p>这题和LCS最大的不同是：</p>
<ul>
<li>LCS只要是子序列都可以</li>
<li>本题必须是相邻的子数组</li>
<li>也就导致了递归公式的不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = A.size();</span><br><span class="line">        <span class="keyword">int</span> b = B.size();</span><br><span class="line">        <span class="keyword">if</span>( a==<span class="number">0</span>||b== <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c[a+<span class="number">1</span>][b+<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> maxnum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=a;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=b;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>)&#123;</span><br><span class="line">                    c[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(A[i<span class="number">-1</span>]==B[j<span class="number">-1</span>])&#123;</span><br><span class="line">                        c[i][j]=c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                         maxnum = <span class="built_in">std</span>::max(maxnum,c[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxnum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="MATH-762-Prime-Number-of-Set-Bits-in-Binary-Representation"><a href="#MATH-762-Prime-Number-of-Set-Bits-in-Binary-Representation" class="headerlink" title="MATH 762. Prime Number of Set Bits in Binary Representation"></a>MATH 762. Prime Number of Set Bits in Binary Representation</h3><ul>
<li>这个题主要是数学</li>
<li><code>n&amp;(n-1)</code>有很多妙用</li>
</ul>
<p>基本原理：</p>
<pre><code>n&amp;(n-1)作用：将n的二进制表示中的最低位为1的改为0，
先看一个简单的例子：n = 10100(二进制），则(n-1) = 10011 ==》n&amp;(n-1) = 10000     
可以看到原本最低位为1的那位变为0。
</code></pre><p>所以可以：</p>
<ol>
<li>用来求一个数二进制数中的1的个数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)  </span><br><span class="line">&#123;  </span><br><span class="line">    count++;  </span><br><span class="line">    n&amp;=(n<span class="number">-1</span>);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用来求一个数是否是2的次幂</li>
</ol>
<p><code>n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0 )</code></p>
<ul>
<li>cpp set的使用</li>
</ul>
<p>注意STL的各种方法和遍历方式。</p>
<h3 id="150-Evaluate-Reverse-Polish-Notation"><a href="#150-Evaluate-Reverse-Polish-Notation" class="headerlink" title="150. Evaluate Reverse Polish Notation"></a>150. Evaluate Reverse Polish Notation</h3><p>知识点：栈的使用<br>盲点：</p>
<ol>
<li>STL容器的遍历使用不熟练</li>
<li>堆栈和switch语句使用不熟练</li>
<li>递归的边界用的不熟悉</li>
</ol>
<p>错误解法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> s = tokens.back();</span><br><span class="line">        tokens.pop_back();</span><br><span class="line">        <span class="keyword">int</span> r2 = evalRPN(tokens);</span><br><span class="line">        <span class="keyword">int</span> r1 = evalRPN(tokens);</span><br><span class="line">            <span class="keyword">switch</span>(s)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"+"</span>: <span class="keyword">return</span> r1+r2;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"-"</span>: <span class="keyword">return</span> r1-r2;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"*"</span>: <span class="keyword">return</span> r1*r2;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"/"</span>: <span class="keyword">return</span> r1/r2;</span><br><span class="line">                <span class="keyword">default</span>: <span class="keyword">return</span> stoi(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>典型的没有考虑边界条件。</p>
<p>正确解</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span> (<span class="keyword">int</span>, <span class="keyword">int</span>) &gt; &gt; <span class="built_in">map</span> = &#123;</span><br><span class="line">            &#123; <span class="string">"+"</span> , [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125; &#125;,</span><br><span class="line">            &#123; <span class="string">"-"</span> , [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a - b; &#125; &#125;,</span><br><span class="line">            &#123; <span class="string">"*"</span> , [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a * b; &#125; &#125;,</span><br><span class="line">            &#123; <span class="string">"/"</span> , [] (<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> a / b; &#125; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">stack</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span>&amp; s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>.count(s)) &#123;</span><br><span class="line">                <span class="built_in">stack</span>.push(stoi(s));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> op1 = <span class="built_in">stack</span>.top();</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="keyword">int</span> op2 = <span class="built_in">stack</span>.top();</span><br><span class="line">                <span class="built_in">stack</span>.pop();</span><br><span class="line">                <span class="built_in">stack</span>.push(<span class="built_in">map</span>[s](op2, op1));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stack</span>.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个用法非常巧妙啊，可以使用hash表构造函数,真是非常优秀</p>
<h3 id="148-Sort-List-链表排序"><a href="#148-Sort-List-链表排序" class="headerlink" title="148. Sort List 链表排序"></a>148. Sort List 链表排序</h3><blockquote>
<p>Sort a linked list in O(n log n) time using constant space complexity.</p>
</blockquote>
<ol>
<li>解题思路：首先看到O(n log n)就可以想到是归并排序，对于查找来说就是二分查找。</li>
<li>如何确定链表的中点在哪里呢？使用快慢指针，快指针一次走两步，慢指针一次走一步，太妙了。</li>
<li>对于两个有序链表的排序可以创建一个新的链表。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先就得考虑边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>||head-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快慢指针求中点，非常聪明</span></span><br><span class="line">        <span class="comment">//将链表一分为二</span></span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//归并法</span></span><br><span class="line">        ListNode* p1 = sortList(fast);</span><br><span class="line">        ListNode* p2 = sortList(head);</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> merge(p1,p2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1,ListNode* l2)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//考虑边界条件</span></span><br><span class="line">        <span class="keyword">if</span>(!l1) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!l2) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!l1 &amp;&amp; !l2) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建一个新的有序链表</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">ListNode <span class="title">dump</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* cur = &amp;dump;</span><br><span class="line">        <span class="comment">//这里进行两个有序链表的排序</span></span><br><span class="line">        <span class="keyword">while</span>(l1&amp;&amp;l2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1-&gt;val&lt;l2-&gt;val)&#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;   </span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果一个链表到了头，直接就接上另外一个链表</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="147-Insertion-Sort-List"><a href="#147-Insertion-Sort-List" class="headerlink" title="147. Insertion Sort List"></a>147. Insertion Sort List</h3><blockquote>
<p>Sort a linked list using insertion sort.</p>
</blockquote>
<p>链表的插入排序<br>思路：使用两个指针两次循环<br>第一个指针记录现在是第几个数被排序<br>第二个指针记录插入的位置。</p>
<p>因为指针之间是相互关联的，所以要考虑指针赋值的顺序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">insertionSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>||head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">ListNode <span class="title">dump</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode* p = &amp;dump;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            p = &amp;dump;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(p-&gt;next&amp;&amp;p-&gt;next-&gt;val&lt;cur-&gt;val)&#123;</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            ListNode* n = p-&gt;next;</span><br><span class="line">            p-&gt;next = cur;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//顺序不能错</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            p-&gt;next-&gt;next = n;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dump.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145. Binary Tree Postorder Traversal"></a>145. Binary Tree Postorder Traversal</h3><p>二叉树后续遍历</p>
<p>emmm，对于地址的引用和面向对象的使用还是不熟悉啊</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode* root) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        travler(root,&amp;ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">travler</span><span class="params">(TreeNode* root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* ans)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        travler(root-&gt;left,ans);</span><br><span class="line">        travler(root-&gt;right,ans);</span><br><span class="line">        ans-&gt;push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>中序，前序同理。</p>
<h3 id="Reorder-List"><a href="#Reorder-List" class="headerlink" title="Reorder List"></a>Reorder List</h3><blockquote>
<p>Given a singly linked list L: L0→L1→…→Ln-1→Ln,<br>reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→…<br>You must do this in-place without altering the nodes’ values.<br>For example,<br>Given {1,2,3,4}, reorder it to {1,4,2,3}.</p>
</blockquote>
<p>主要有三步：</p>
<ul>
<li>快慢指针找到切分链表</li>
<li>翻转右半部分</li>
<li>依次合并</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//快慢指针切分链表</span></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//翻转右半部分</span></span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(fast) &#123;</span><br><span class="line">            ListNode* n = dummy.next;</span><br><span class="line">            dummy.next = fast;</span><br><span class="line">            ListNode* nn = fast-&gt;next;</span><br><span class="line">            fast-&gt;next = n;</span><br><span class="line">            fast = nn;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = head;</span><br><span class="line">        fast = dummy.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依次合并</span></span><br><span class="line">        <span class="keyword">while</span>(slow) &#123;</span><br><span class="line">            <span class="keyword">if</span>(fast != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ListNode* n = slow-&gt;next;</span><br><span class="line">                slow-&gt;next = fast;</span><br><span class="line">                ListNode* nn = fast-&gt;next;</span><br><span class="line">                fast-&gt;next = n;</span><br><span class="line">                fast = nn;</span><br><span class="line">                slow = n;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>做指针链表类的题目：</p>
<ol>
<li>学会新建链表</li>
<li>如果链表有断裂的，只需要将链表断裂的那个位置记下来</li>
</ol>
<h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. Linked List Cycle II</h3><p>其实是个数学题</p>
<p><img src="http://osmisz4zw.bkt.clouddn.com/15179080653684.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1). 使用快慢指针法，若链表中有环，可以得到两指针的交点M</span><br><span class="line"></span><br><span class="line">2). 记链表的头节点为H，环的起点为E</span><br><span class="line"></span><br><span class="line">2.1) L1为H到E的距离</span><br><span class="line">2.2) L2为从E出发，首次到达M时的路程</span><br><span class="line">2.3) C为环的周长</span><br><span class="line">2.4) n为快慢指针首次相遇时，快指针在环中绕行的次数</span><br><span class="line"></span><br><span class="line">根据L1,L2和C的定义，我们可以得到：</span><br><span class="line"></span><br><span class="line">慢指针行进的距离为L1 + L2</span><br><span class="line"></span><br><span class="line">快指针行进的距离为L1 + L2 + n * C</span><br><span class="line"></span><br><span class="line">由于快慢指针行进的距离有2倍关系，因此：</span><br><span class="line"></span><br><span class="line">2 * (L1+L2) = L1 + L2 + n * C =&gt; L1 + L2 = n * C =&gt; L1 = (n - 1)* C + (C - L2)</span><br><span class="line"></span><br><span class="line">可以推出H到E的距离 = 从M出发绕环到达E时的路程</span><br><span class="line"></span><br><span class="line">因此，当快慢指针在环中相遇时，我们再令一个慢指针从头节点出发</span><br><span class="line"></span><br><span class="line">接下来当两个慢指针相遇时，即为E所在的位置</span><br></pre></td></tr></table></figure>
<p>解答</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>||head-&gt;next == <span class="literal">NULL</span>||head-&gt;next-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* fast = head-&gt;next-&gt;next;</span><br><span class="line">        ListNode* slow = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="literal">NULL</span>||fast-&gt;next==<span class="literal">NULL</span>||fast-&gt;next-&gt;next==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//这里要判断没有成环的情况</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow2 = head;</span><br><span class="line">        <span class="keyword">while</span>(slow2!=slow)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            slow2 = slow2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="141">
<li>Linked List Cycle</li>
</ol>
<p>还是使用快慢指针的方法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="139">
<li>Word Break</li>
</ol>
<p>这个问题为什么要从后往前考虑，而不是从前往后考虑呢？</p>
<p>思路：Word Break I</p>
<p>看到这题第一反应是DFS枚举查找，直到“探”到string尾部则算成功。但题目并不要求给出是如何break的，而只要判断是否能break。对这类判断“是”与“否”的可以用DFS暴力解决的题，可以尝试用DP做book keeping中间判断状态，避免DFS的反复搜索。比如这题，可以用一个数组dp记录S[0:i]是否能break。</p>
<p>[Thoughts]<br>一个DP问题。定义possible[i] 为S字符串上[0,i]的子串是否可以被segmented by dictionary.</p>
<p>那么</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">possible[i] = true      if  S[0,i]在dictionary里面</span><br><span class="line">            = true      if   possible[k] == true 并且 S[k+1,j]在dictionary里面,0&lt;k&lt;i</span><br><span class="line">            = false      if    no such k exist.</span><br></pre></td></tr></table></figure>
<h3 id="136-Single-Number"><a href="#136-Single-Number" class="headerlink" title="136. Single Number"></a>136. Single Number</h3><blockquote>
<p>Given an array of integers, every element appears twice except for one. Find that single one.<br>Note:<br>Your algorithm s hould have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<p>用异或来解决这个问题真是神来之笔啊</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter = nums.begin();iter!=nums.end();iter++)&#123;</span><br><span class="line">            result = (*iter)^result;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以这么做的三个原因</p>
<ol>
<li>0和任何数异或都是该数</li>
<li>两个相同的数异或为0</li>
<li>异或满足交换律</li>
</ol>
<p>所以这个计算方式就是将所有的数异或运算，再拿0和那个single one异或运算<br>神来之笔</p>
<h3 id="137-Single-Number-II"><a href="#137-Single-Number-II" class="headerlink" title="137. Single Number II"></a>137. Single Number II</h3><blockquote>
<p>Given an array of integers, every element appears three times except for one, which appears exactly once. Find that single one.<br>Note:<br>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
</blockquote>
<p>实话说没搞懂，留着吧<br><a href="http://blog.csdn.net/qq508618087/article/details/50450165" target="_blank" rel="noopener">解析在这里</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> one =<span class="number">0</span>, two=<span class="number">0</span>, three=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val: nums)  </span><br><span class="line">        &#123;  </span><br><span class="line">            two |= (val&amp;one);  </span><br><span class="line">            one ^= val;  </span><br><span class="line">            three = (one&amp;two);  </span><br><span class="line">            one ^= three;  </span><br><span class="line">            two ^= three;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> one;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="134-Gas-Station-贪心算法"><a href="#134-Gas-Station-贪心算法" class="headerlink" title="134. Gas Station 贪心算法"></a>134. Gas Station 贪心算法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">There are N gas stations along a circular route, where the amount of gas at station i is gas[i].</span><br><span class="line"></span><br><span class="line">You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.</span><br><span class="line"></span><br><span class="line">Return the starting gas station&apos;s index if you can travel around the circuit once, otherwise return -1.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">The solution is guaranteed to be unique.</span><br></pre></td></tr></table></figure>
<p>其实我没有理解这题哪里贪心算法了。。。</p>
<p><a href="http://bangbingsyb.blogspot.sg/2014/11/leetcode-gas-station.html?showComment=1451365790877#c6919864995594632399" target="_blank" rel="noopener">解题参考</a></p>
<blockquote>
<p>这题要想清楚不容易，尽管想清楚后代码写起来很简单。</p>
</blockquote>
<blockquote>
<p>I.  显然当gas[i]&lt;cost[i]时，i不能作为起点。</p>
</blockquote>
<blockquote>
<p>II. 当对所有加油站求和：sum(gas[i] - cost[i]) &lt;0时，无法环绕一圈。反之，则一定能环绕一圈。</p>
</blockquote>
<blockquote>
<p>问题是如果可以环绕一圈，如何找起点？</p>
</blockquote>
<blockquote>
<p>性质1. 对于任意一个加油站i，假如从i出发可以环绕一圈，则i一定可以到达任何一个加油站。显而易见。</p>
</blockquote>
<blockquote>
<p>性质2. 如果这样的i是唯一的，则必然不存在j!=i， 从j出发可以到达i。</p>
</blockquote>
<blockquote>
<p>反证法：如果存在这样的j，则必然存在j-&gt;i-&gt;i的路径，而这个路径会覆盖j-&gt;j一周的路径。那么j也将是一个符合条件的起点。与唯一解的限制条件矛盾。</p>
</blockquote>
<blockquote>
<p>性质3. 假如i是最后的解，则由1可知，从0 ~ i-1出发无法达到i。而从i出发可以到达i+1 ~ n-1。</p>
</blockquote>
<blockquote>
<p>结合以上三条性质，得出解决的思路：</p>
</blockquote>
<blockquote>
<p>总结一下，就是</p>
</blockquote>
<blockquote>
<ol start="0">
<li>如果对所有加油站的sum(gas[i] - cost[i])&lt;0，则无解。否则进入1。</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>从0开始计算sum(gas[i] - cost[i])，当遇到i1使sum&lt;0时，说明从0出发无法到达i1。根据性质1，0不是起始点。而由于从0出发已经到达了1 ~ i1-1。根据性质2，1 ~ i1-1一定不是正确的起始点。而且因为直到i1-1，sum都是大于0的，所以说明gas[i1] – cost[i1] 一定小于0，所以i1也不是start，所以start = i1 + 1 而不是start = i1</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>将sum清0，并从i1出发，假如又遇到i2使sum(gas[i] - cost[i]) &lt; 0 时，说明i1出发无法绕一圈，更具性质1，排除i1。又因为i1+1 ~ i2-1都能从i1出发到达,。根据性质2，它们也必然不是起始点。此时i2为起始点的候选。而且因为直到i2-1，sum都是大于0的，所以说明gas[i2] – cost[i2] 一定小于0，所以i2也不是start，所以start = i2 + 1 而不是start = i2</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>以此类推，直到遇到ik，使从ik出发可以到达ik+1 ~ n-1。</li>
</ol>
</blockquote>
<p>上代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canCompleteCircuit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; gas, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> netSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;cost.size();i++)&#123;</span><br><span class="line">            netSum += gas[i] - cost[i];</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">                result = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(netSum&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="133-Clone-Graph-图的遍历"><a href="#133-Clone-Graph-图的遍历" class="headerlink" title="133. Clone Graph 图的遍历"></a>133. Clone Graph 图的遍历</h3><p>这里的clone和引用要搞清楚</p>
<p>这里的答案是错的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp.find(node)==mp.end())&#123;</span><br><span class="line">            mp[node]= <span class="keyword">new</span>  UndirectedGraphNode(node-&gt;label);</span><br><span class="line">            mp[node]-&gt;neighbors = node-&gt;neighbors;</span><br><span class="line">            <span class="keyword">for</span>(UndirectedGraphNode * val:node-&gt;neighbors)&#123;</span><br><span class="line">                cloneGraph(val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[node];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>报错如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">Output:</span><br><span class="line">Node with label <span class="number">0</span> was <span class="keyword">not</span> copied but a reference to the original one.</span><br><span class="line">Expected:&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我的理解是，有些复制是引用，有些复制是重新开辟空间，所以上面的复制是有问题的。</p>
<p>下面的方法使用DFS，递归的方法实现了图的遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for undirected graph.</span></span><br><span class="line"><span class="comment"> * struct UndirectedGraphNode &#123;</span></span><br><span class="line"><span class="comment"> *     int label;</span></span><br><span class="line"><span class="comment"> *     vector&lt;UndirectedGraphNode *&gt; neighbors;</span></span><br><span class="line"><span class="comment"> *     UndirectedGraphNode(int x) : label(x) &#123;&#125;;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">UndirectedGraphNode *<span class="title">cloneGraph</span><span class="params">(UndirectedGraphNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(mp.find(node)==mp.end())&#123;</span><br><span class="line">            mp[node]= <span class="keyword">new</span>  UndirectedGraphNode(node-&gt;label);</span><br><span class="line">            <span class="keyword">for</span>(UndirectedGraphNode * val:node-&gt;neighbors)&#123;</span><br><span class="line">            <span class="comment">//这里很关键，</span></span><br><span class="line">            <span class="comment">//mp[node]-&gt;neighbors.push_back(cloneGraph(val));表示克隆</span></span><br><span class="line">            <span class="comment">//mp[node]-&gt;neighbors.push_back(val);表示引用</span></span><br><span class="line">                mp[node]-&gt;neighbors.push_back(cloneGraph(val));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mp[node];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;UndirectedGraphNode*, UndirectedGraphNode*&gt; mp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="747-Largest-Number-At-Least-Twice-of-Others"><a href="#747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="747. Largest Number At Least Twice of Others"></a>747. Largest Number At Least Twice of Others</h3><p>这就很简单了，两次遍历</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">int</span> max2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;max)&#123;</span><br><span class="line">                max = nums[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;nums.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j==index) <span class="keyword">continue</span>;</span><br><span class="line">            max2 = max2&gt;nums[j]*<span class="number">2</span>?max2:nums[j]*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max2&gt;max) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>优化：</p>
<ol>
<li>其实在第二次for循环中不需要将整个循环都循环完毕，只要出现一个max2比max大，那就可以终止了。</li>
</ol>
<h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26. Remove Duplicates from Sorted Array"></a>26. Remove Duplicates from Sorted Array</h3><p>这题对基础的锻炼</p>
<ol>
<li>迭代器的使用</li>
<li>迭代器转换成index</li>
<li>vector删除某个元素</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = nums.begin()+<span class="number">1</span>;it&lt;nums.end();)&#123;</span><br><span class="line">            last = *(it<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span>(last==*it)&#123;</span><br><span class="line">                it = nums.erase(it);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a>27. Remove Element</h3><p>基础题</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = nums.begin();it&lt;nums.end();)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it == val)&#123;</span><br><span class="line">                it = nums.erase(it);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="125-Valid-Palindrome-递归基础题"><a href="#125-Valid-Palindrome-递归基础题" class="headerlink" title="125. Valid Palindrome 递归基础题"></a>125. Valid Palindrome 递归基础题</h3><blockquote>
<p>Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.<br>For example,<br>“A man, a plan, a canal: Panama” is a palindrome.<br>“race a car” is not a palindrome.<br>Note:<br>Have you consider that the string might be empty? This is a good question to ask during an interview.<br>For the purpose of this problem, we define empty string as valid palindrome.</p>
</blockquote>
<p>主要问题是对cpp的核心API不够清楚</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r= s.size() <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(s[l])==<span class="number">0</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isalnum</span>(s[r])==<span class="number">0</span>)&#123;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">tolower</span>(s[l])==<span class="built_in">tolower</span>(s[r]))&#123;</span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="680-Valid-Palindrome-II"><a href="#680-Valid-Palindrome-II" class="headerlink" title="680. Valid Palindrome II"></a>680. Valid Palindrome II</h3><p>同理 加了一层递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">validPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>; i &lt; j; i++, j--)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> isp(s, i + <span class="number">1</span>, j) || isp(s, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isp</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = l, j = r; i &lt; j; i++, j--)</span><br><span class="line">            <span class="keyword">if</span> (s[i] != s[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="617-Merge-Two-Binary-Trees"><a href="#617-Merge-Two-Binary-Trees" class="headerlink" title="617. Merge Two Binary Trees"></a>617. Merge Two Binary Trees</h3><p>这里注意指针引用和对象的关系</p>
<p>如果只是单纯的指针是不能用 result-&gt;val的因为没有开辟空间</p>
<p>必须是 result = new TreeNode(val)<br>才可以</p>
<p>tip2<br>题中的分类可以设定为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t1&amp;&amp;t2)&#123;</span><br><span class="line">    <span class="comment">//这里表示t1和t2都是非空的</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1?t1:t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* t1, TreeNode* t2)</span> </span>&#123;</span><br><span class="line">        TreeNode* result;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">NULL</span>&amp;&amp;t2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            result = t2;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t2==<span class="literal">NULL</span>&amp;&amp;t1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            result = t1;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(t1==<span class="literal">NULL</span>&amp;&amp;t2==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="keyword">new</span> TreeNode(t1-&gt;val + t2-&gt;val);</span><br><span class="line">        result-&gt;left = mergeTrees(t1-&gt;left,t2-&gt;left);</span><br><span class="line">        result-&gt;right = mergeTrees(t1-&gt;right,t2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#LeetCode" >
    <span class="tag-code">LeetCode</span>
  </a>

  <a href="/tags#算法刷题" >
    <span class="tag-code">算法刷题</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2017/08/06/qinghai/">
        <span class="nav-arrow">← </span>
        
          qinghai
        
      </a>
    
    
      <a class="nav-right" href="/2018/01/26/2018-01-26/">
        
          无问西东观影
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
      <div class="money-like">
        <div class="reward-btn">
          赏
          <span class="money-code">
            <span class="alipay-code">
              <div class="code-image"></div>
              <b>使用支付宝打赏</b>
            </span>
            <span class="wechat-code">
              <div class="code-image"></div>
              <b>使用微信打赏</b>
            </span>
          </span>
        </div>
        <p class="notice">若你觉得我的文章对你有帮助，欢迎点击上方按钮对我打赏</p>
      </div>
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
      <div class="qrcode">
        <canvas id="share-qrcode"></canvas>
        <p class="notice">扫描二维码，分享此文章</p>
      </div>
    
    <!-- 二维码 END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Day-1"><span class="toc-nav-text">Day 1</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#暴力解"><span class="toc-nav-text">暴力解</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#使用hash-对应CPP是-unordered-map"><span class="toc-nav-text">使用hash 对应CPP是 unordered_map</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#3Sum问题"><span class="toc-nav-text">3Sum问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#九章解法"><span class="toc-nav-text">九章解法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#111-Minimum-Depth-of-Binary-Tree"><span class="toc-nav-text">111. Minimum Depth of Binary Tree</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#BFS解法"><span class="toc-nav-text">BFS解法</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#递归解法"><span class="toc-nav-text">递归解法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#链表：237-Delete-Node-in-a-Linked-List-easy"><span class="toc-nav-text">链表：237. Delete Node in a Linked List -easy</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#数组：Maximum-Length-of-Repeated-Subarray-Mid"><span class="toc-nav-text">数组：Maximum Length of Repeated Subarray -Mid</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#MATH-762-Prime-Number-of-Set-Bits-in-Binary-Representation"><span class="toc-nav-text">MATH 762. Prime Number of Set Bits in Binary Representation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#150-Evaluate-Reverse-Polish-Notation"><span class="toc-nav-text">150. Evaluate Reverse Polish Notation</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#148-Sort-List-链表排序"><span class="toc-nav-text">148. Sort List 链表排序</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#147-Insertion-Sort-List"><span class="toc-nav-text">147. Insertion Sort List</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#145-Binary-Tree-Postorder-Traversal"><span class="toc-nav-text">145. Binary Tree Postorder Traversal</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Reorder-List"><span class="toc-nav-text">Reorder List</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#142-Linked-List-Cycle-II"><span class="toc-nav-text">142. Linked List Cycle II</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#136-Single-Number"><span class="toc-nav-text">136. Single Number</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#137-Single-Number-II"><span class="toc-nav-text">137. Single Number II</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#134-Gas-Station-贪心算法"><span class="toc-nav-text">134. Gas Station 贪心算法</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#133-Clone-Graph-图的遍历"><span class="toc-nav-text">133. Clone Graph 图的遍历</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#747-Largest-Number-At-Least-Twice-of-Others"><span class="toc-nav-text">747. Largest Number At Least Twice of Others</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#26-Remove-Duplicates-from-Sorted-Array"><span class="toc-nav-text">26. Remove Duplicates from Sorted Array</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#27-Remove-Element"><span class="toc-nav-text">27. Remove Element</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#125-Valid-Palindrome-递归基础题"><span class="toc-nav-text">125. Valid Palindrome 递归基础题</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#680-Valid-Palindrome-II"><span class="toc-nav-text">680. Valid Palindrome II</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#617-Merge-Two-Binary-Trees"><span class="toc-nav-text">617. Merge Two Binary Trees</span></a></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://dekura.github.io/2018/01/24/leetcode/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "dekura";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "LeetCode刷题记录",
        owner: "dekura",
        repo: "dekura.github.io",
        oauth: {
          client_id: "97e1d6e9653a91635905",
          client_secret: "97ec9074518f7f02d092d022183c6ba6effbb2c1"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2018 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>